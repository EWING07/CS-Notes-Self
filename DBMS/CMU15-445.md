# CMU Database Systems

> Reference: [CMU Database Group](https://www.youtube.com/channel/UCHnBsf2rH-K7pn09rb3qvkA), [CMU 15-445/645](https://15445.courses.cs.cmu.edu/fall2019/), 《高性能MySQL》

## Lecture #01: Relational Model & Relational Algebra

### 1 Database

Definition: an organized collection of inter-related data that models some aspects of the real-world.

Databases are core the component of most computer apps.

DBMS is different from databases.

### 2. Flat File Strawman

Database is stored as comma-separeted value(CSV) files that the DBMS manages.

#### Issues with Flat File

- Data Integrity
- Implementation
- Durability

### 3. Database Management System

a DBMS is software that allows applications to store and analyze information in a database.

allow the definition, creation, querying, updating, and administration of databases.

The logic layer is  which entities and attributes the database has while the physical layer is how those entities and attributes are being stored.

### 4. Relational Model

3 key points:

- Store database in simple data stcutures(relations)
- access data through high-level language.
- physical storage left up to implementation

a data model is a collection of concepts for describing the data in a database. (relational model is an example  of a data model)

a *schema* is  a description of a particular collection of data, using a given data model.

The relational data model defines three concepts:

- **Structure**: the definition of relations and their contents. this is the attributes the relations have and the values that those attributes can hold.
- **Integrity**: ensure the database's contents satisfy constraints.
- **Manipulation**: how to access and modify a database's contents

#### Keys

a primary key uniquely identifies a single tuple. 

a foreign key specifies that an attribute from one relation has to map to a tuple in anotehr relation

### 5. Data Manipulation Language

a language to store and retrieve information from a database.

- **Procedural**: the query specifies the strategy the DBMS should use to find the desired result.
- **Non-Procedura**l: the query specifies only what data is wanted and not how to find it.

### 6. Relational Algebra

a set of fundamental operations to retrieve and manipulate tuples in a relation. (is a procedural language cuz it defines the high level-steps of how to compute a query)

*Select, Projection, Union, Intersection, Difference, Product, Join*

**Join**: Join takes in two relations and outputs a relation that contains all the tuples that are a combination of two tuples where for each attribute that the two relations share, the values for that attrubite of both tuples is the same.

![img](/Users/ewing/Documents/GitHub/CS-Notes-Self/DBMS/sql-join.png)

### Conclusion

Databases are ubiquitous

Relational algebra defines the primitives for processing queries on a relational database.

## Lecture #02: Advanced SQL

#### 1 Relational Languages

Relational algebra is based on sets, SQL is based on bags

#### 2 SQL History

Comprised of 3 classes of commands:

- DML: `SELECT, INSERT, UPDATE, DELETE`
- DDL: Schema definition
- DCL: Security, access control

SQL-92 is the minimum that a DBMS has to support

#### 3 Aggregates

<img src="image-20201016172052545.png" alt="image-20201016172052545" style="zoom:50%;" />

#### 4 String Operations

#### 5 Output Redirection

<img src="image-20201016172213444.png" alt="image-20201016172213444" style="zoom:50%;" />

#### 6 Output Control

Order By: impose a sort on tuples

LIMIT: restrict the number of result tuples

#### 7 Nested Queries

<img src="image-20201016172659100.png" alt="image-20201016172659100" style="zoom:50%;" />

#### 8 Window Functions

- **Functions**: can be any of the aggregation functions that we discussed above. can also be a special window functions:
  - `ROW_NUMBER`: the number of the current row
  - `RANK`: the order position of the current row
- **Grouping**: The `OVER` clause specifies how to group together tuples when computing the window function. Use `PARTITION` BY to specify group.
- **Important**: The DBMS computes `RANK` after the window function sorting, whereas it computes `ROW NUMBER`before the sorting.

#### 9 [Common Table Expression](https://sqlite.org/lang_with.html)

Common Table Expressions (CTEs) are an alternative to windows or nested queries to writing more complex queries. One can think of a CTE like a temporary table for just one query.

## Lecture #03 Database Storage (Part I)

### 1. Storage

File storage page layout tuple layout

1. foucs on a disk-oriented DBMS that primary storage location of the databses is on non-volatile disk
2. **Volatile Devices:** 
   - Volatile means that if you pull the power from the machine, then the data is lost. 
   - Volatile storage supports fast random access with byte-addressable locations. This means that the program can jump to any byte address and get the data that is there. 
   - For our purposes, we will always refer to this storage class as “memory”
3. **Non-Volatile Devices:**
   - Non-volatile means that the storage device does not need to be provided continuous power in order for the device to retain the bits that it is storing. 
   - It is also block/page addressable. This means that in order to read a value at a particular offset, the program first has to load the 4 KB page into memory that holds the value the program wants to read. 
   - Non-volatile storage is traditionally better at sequential access (reading multiple chunks of data at the same time). 
   - We will refer to this as “disk”. We will not make a (major) distinction between solid-state storage (SSD) or spinning hard drives (HDD).

### 2. Disk-Oriented DBMS Overview

![image-20201023164907981](image-20201023164907981.png)

### 3. DBMS vs. OS

High-level design goal is like virtual memory, where there us a large addres space and a place for the OS to bring in pages from disk.

We do not advise using `mmap` in a DBMS for correctness and performance reasons. Even though the system will have functionalities that seem like something the OS can provide, Having the DBMS implement these procedures itself gives it better control and performance.

### 4. File Storage

a DBMS stores a database as files on disk.

The OS does not know anything about the contents of these files. Only the DBMS knows how to decipher their contents, since it is encoded in a way specific to the DBMS.

The DBMS’s `storage manager` is responsible for managing a database’s files. It represents the files as a collection of pages. It also keeps track of what data has been read and written to pages, as well how much free space there is in the pages

### 5. Database pages 

![image-20201023170027798](image-20201023170027798.png)

Most DBMSs have an indirection layer that maps a page id to a file path and offset.

There are three concepts of pages in DBMS: 

1. Hardware page (usually 4 KB). 
2. OS page (4 KB). 
3. Database page (1-16 KB).

### 6. Database Heap

A heap file is an unordered collection of pages where tuples are stored in random order.

The DBMS can locate a page on disk given a page id by using a linked list of pages or a page directory. 

- **Linked List**: Header page holds pointers to to a list of free pages and a list of data pages. However, if the DBMS is looking for a specific page, it has to do a sequential scan on the data page list until it finds the page it is looking for. 
- **Page Directory**: DBMS maintains special pages that track locations of data pages along with the amount of free space on each page.

### 7. Page Layout

Every page includes a header that records meta-data about the page’s contents: 

- Page size. 
- Checksum. 
- DBMS version. 
- Transaction visibility. 
- Some systems require pages to be self-contained (e.g oracle)

2 main approaches laying out data in pages:

1. **Slotted-pages**: pages maps slots to offsets
   - Most common approach used in DBMSs today. 
   - Header keeps track of the number of used slots and the offset of the starting location of last used slot and a slot array, which keeps track of the location of the start of each tuple. 
   - To add a tuple, the slot array will grow from the beginning to the end, and the data of the tuples will grow from end to the beginning. The page is considered full when the slot array and the tuple data meet.
2. **Log-structured**:  Instead of storing tuples, the DBMS only stores log records.
   - Stores records to file of how the database was modified (insert, update, deletes). 
   - To read a record, the DBMS scans the log file backwards and “recreates” the tuple. 
   - Fast writes, potentially slow reads. 
   - Works well on append-only storage because the DBMS cannot go back and update the data. 
   - To avoid long reads the DBMS can have indexes to allow it to jump to specific locations in the log. It can also periodically compact the log (if it had a tuple and then made an update to it, it could compact it down to just inserting the updated tuple). The issue with compaction is the DBMS ends up with write amplification (it re-writs the same data over and over again).

### 8. Tuple Layout

A tuple is essentially a sequence of bytes. It is DBMS’s job to interpret those bytes into attribute types and values. 

**Tuple Header**: Contains meta-data about the tuple. 

- Visibility information for the DBMS’s concurrency control protocol (i.e., information about which transaction created/modified that tuple). 
- Bit Map for NULL values. 
- Note that the DBMS does not need to store meta-data about the schema of the database here. 

**Tuple Data**: Actual data for attributes. 

- Attributes are typically stored in the order that you specify them when you create the table. 
- Most DBMSs do not allow a tuple to exceed the size of a page.

**Unique Identifier**: 

- Each tuple in the database is assigned a unique identifier. 
- Most common: page id + (offset or slot). 
- An application cannot rely on these ids to mean anything.

**Denormalized Tuple Data**: If two tables are related, the DBMS can “pre-join” them, so the tables end up on the same page. This makes reads faster since the DBMS only has to load in one page rather than two separate pages, but it makes updates more expensive since the DBMS needs more space for each tuple.

## Lecture #04: Database Storage (Part II)

> [存储模型和数据布局](https://blog.csdn.net/u013007900/article/details/78908526)

### 1. Data Representation

Tuple's data is essentially just bytes arrays. 取决于DBMS怎么interpret他们去derive属性值。

有四种主要的类型：integers, variable precision numbers, fixed point precision numbers, variable length values, and dates/times;

- **Integers**
  - use C/C++ types as specified by the IEEE-754 standard. these values are fixed length.
  - exampels: `INTEGER,BIGINT,SMALLINT,TINYINT`
- **Variable Precision Numbers**
  - variable-precision numeric type that uses C/C++ types as specified by the IEEE-754 standard. these values are fixed length.
  - Variable-precision numbers are faster to compute than arbitrary precision numbers because the CPU can execute instructions on them directly.
  - examples: `FLOAT,REAL`
- **Fixed Point Precision Numbers**
  -  numeric data types with arbitrary precision and scale. They are typically stored in exact, variable-length binary representation with additional meta-data that will tell the system things like where the decimal should be
  - These data types are used when rounding errors are unacceptable, but the DBMS pays a performance penalty to get this accuracy.
  - Examples: `NUMERIC, DECIMAL`
- **Variable Length Data**
  - An array of bytes of arbitrary length. 
  - Has a header that keeps track of the length of the string to make it easy to jump to the next value. 
  - Most DBMSs do not allow a tuple to exceed the size of a single page, so they solve this issue by writing the value on an overflow page and have the tuple contain a reference to that page. 
  - Some systems will let you store these large values in an external file, and then the tuple will contain a pointer to that file. For example, if our database is storing photo information, we can store the photos in the external files rather than having them take up large amounts of space in the DBMS. One downside of this is that the DBMS cannot manipulate the contents of this file.
  - Examples: `VARCHAR,VARBINARY,TEXT,BLOB`
- **Dates and Times**
  - Usually, these are represented as the number of (micro/milli)seconds since the unix epoch. 
  - Example: `TIME, DATE, TIMESTAMP.`

### 2. Workloads

- **OLTP: On-Line Transaction Processing**
  - Fast, short running operations
  - Queries operate on single entity at a time
  - More writes than reads.
  - Repetitive operations
  - Usually the kind of application that people build first
  - Example: User invocations of Amazon. They can add things to their cart, they can make purchases, but the actions only affect their account.
- **OLAP: On-Line Analytical Processing**
  - Long running, more complex queries
  - Reads large portions of the database
  - Exploratory queries
  - Deriving new data from data collected on the OLTP side
  - Example: Compute the five most bought items over a one month period for these geographical locations.

### 3. Storage Models

- **N-Ary Storage Model(NSM)**

  - row store, 适合OLTP
  - 优点：
    - 快速插入，更新和删除
    - 对查询整个tuple很友好
  - 缺点：
    - Not good for scanning large portions of the table and/or a subset of the attributes. This is because it pollutes the buffer pool by fetching data that is not needed for processing the query.
  - 组织方式：
    - **Heap-Organized Tables**: Tuples are stored in blocks called a heap, and the heap does not necessarily define an order. 
    - **Index-Organized Tables**: Tuples are stored in the primary key index itself, but different from a clustered index.

- **Decomposition Storage Model(DSM)**

  - column store, 适合OLAP

  - 优点：

    - Reduces the amount of wasted work during query execution because the DBMS only reads the data that it needs for that query. 
    - Enables better compression because all of the values for the same attribute are stored contiguously

  - 缺点：

    - Slow for point queries, inserts, updates, and deletes because of tuple splitting/stitching.

  - 组织方式：

    - **Fixed-length offsets:** Start by assuming the attributes are all fixed-length. Then when the system wants the attribute for a specific tuple, it knows how to jump to that spot in the file. To accommodate the variable-length fields, the system can pad them so that they are all the same length, or you could use a dictionary that takes a fixed-size integer and maps the integer to the value. 

    <img src="https://lh3.googleusercontent.com/-6Gc0SusjMwo/WkL2i2YZCAI/AAAAAAAAAYs/hXldSvn24rQxQuNOY70J_E7fXt0rOuJwwCHMYCw/I/15143344438019.jpg" alt="img" style="zoom:50%;" />

    - **Embedded Tuple Ids:** For every attribute in the columns, store the tuple id with it. The system would also need extra information to tell it how to jump to every attribute that has that id.

    <img src="https://lh3.googleusercontent.com/-AG7nsSOAfXE/WkL2jCkzMFI/AAAAAAAAAYw/cuBFiJDwARoe4Oe7p2aNNXuSmrHddGfxgCHMYCw/I/15143344921317.jpg" alt="img" style="zoom:50%;" />

